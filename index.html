<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Rainbow Staves</title>
</head>

<body>
  <h2>Rainbow Staves</h2>
  <p id="status">Rainbow Stave is loading...</p>
  <div>
    <div class="inputoutput">
      <img id="wholenote" src='./wholenote.png' />
      <canvas id="canvasOutput"></canvas>
      <img id="imageSrc" alt="" />
      <div class="caption">
        Sheet Music file to Colourize ->
        <input type="file" id="fileInput" name="file" />
      </div>
    </div>
  </div>
  <script type="text/javascript">
    //TODO:
    // * SORT (cnts, boundingBoxes) = sort_contours(cnts, method="top-to-bottom")
    // REMOVE HORIZONTAL LINES THAT ARE TOO SHORT (ONLY USE THE LONG ONES)
    // DRAW OVER NOTES to place them on top of the staves unless there's a better approach
    // SAVE OPTIONS
    // use PDF's

    let imgElement = document.getElementById('imageSrc');
    let inputElement = document.getElementById('fileInput');
    inputElement.addEventListener(
      'change',
      (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);
      },
      false
    );

    function sortContours(contours) {
      let sortableContours = [];
      for (let i = 0; i < contours.size(); i++) {
        const rect = cv.boundingRect(contours.get(i));
        sortableContours.push({ x: rect.x, y: rect.y, width: rect.width, height: rect.height });
      }

      //Sort 'em
      sortableContours = sortableContours.sort((item1, item2) => {
        return (item1.y < item2.y) ? -1 : (item1.y > item2.y) ? 1 : 0;
      });

      // for (idx in sortableContours) {
      //   const contour = sortableContours[idx]
      //   console.log(`sorted contour ${JSON.stringify(contour)}`)
      // }

      return sortableContours
    }

    function myCode() {
      let gray = cv.imread('wholenote', 0)

      let src = cv.imread(imgElement);
      let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC4);
      src.copyTo(dst);

      gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_BGR2GRAY, 0);

      thresh = new cv.Mat();
      cv.threshold(
        gray,
        thresh,
        0,
        255,
        cv.THRESH_BINARY_INV + cv.THRESH_OTSU
      )[1];

      let horizontal_kernel = cv.Mat.ones(1, 40, cv.CV_8U);
      let anchor = new cv.Point(-1, -1);

      detect_horizontal = new cv.Mat();
      cv.morphologyEx(
        thresh,
        detect_horizontal,
        cv.MORPH_OPEN,
        horizontal_kernel,
        anchor,
        2
      );

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();

      cv.findContours(
        detect_horizontal,
        contours,
        hierarchy,
        cv.RETR_EXTERNAL,
        cv.CHAIN_APPROX_SIMPLE
      );

      const colours = [
        [245, 80, 87, 255],
        [237, 177, 231, 255],
        [67, 74, 220, 255],
        [165, 216, 180, 255],
        [223, 230, 100, 255],
        [252, 172, 60, 255],
        [245, 80, 87, 255],
        [213, 95, 204, 255],
        [67, 74, 220, 255],
        [165, 216, 180, 255],
      ];

      const sortedContours = sortContours(contours)

      // work out how long the staves are (mostly)
      let maxLength = 0
      let minLength = 9999
      let total = 0
      let counter = 0
      for (i in sortedContours) {
        counter += 1
        const rect = sortedContours[i];
        maxLength = Math.max(maxLength, rect.width);
        minLength = Math.min(minLength, rect.width)
        total = total + rect.width;
      }

      console.log(`sortedContours.length ${counter}`)
      const averageWidth = total / counter;
      console.log(`length min ${minLength} max ${maxLength} average ${averageWidth}`)



      //TODO: draw over the notes to place them on top of the staves unless there's a better approach
      // edge_kernel = np.array([[ 0.0, -1, 0],
      //                         [ -1, 4, -1],
      //                         [ 0, -1, 0]], dtype=np.uint8)

      let threshed = new cv.Mat();
      cv.threshold(
        gray,
        threshed,
        100,
        255,
        cv.THRESH_BINARY_INV | cv.THRESH_OTSU)

      let edge_contours = new cv.MatVector();
      cv.findContours(
        threshed,
        edge_contours,
        cv.RETR_LIST,
        cv.CHAIN_APPROX_SIMPLE)[-2]

      // edge_kernel = cv.matFromArray(3, 3, cv.CV_8U,
      //   [
      //     [0.0, -1, 0],
      //     [- 1, 4, -1],
      //     [0, -1, 0]
      //   ])
      // const edge_anchor = new cv.Point(1, 1);

      // detect_edge = new cv.Mat()
      // cv.morphologyEx(
      //   thresh,
      //   detect_edge,
      //   cv.MORPH_OPEN,
      //   edge_kernel,
      //   edge_anchor,
      //   2)

      // let edge_contours = new cv.MatVector();
      // let edge_hierarchy = new cv.Mat();
      // cv.findContours(
      //   detect_edge,
      //   edge_contours,
      //   edge_hierarchy,
      //   cv.RETR_EXTERNAL,
      //   cv.CHAIN_APPROX_SIMPLE)


      // draw contours
      let colour_idx = 0;
      for (i in sortedContours) {
        const rect = sortedContours[i];

        // Only draw horizontal lines  which are long enough to be considered part of the stave
        if (rect.width > maxLength / 2) {
          let colour = colours[colour_idx];
          colour_idx = colour_idx + 1;
          if (colour_idx == colours.length) {
            colour_idx = 0;
          }
          cv.rectangle(src,
            new cv.Point(rect.x, rect.y),
            new cv.Point(rect.x + rect.width, rect.y + rect.height),
            colour,
            1)
        }
      }

      // cnts = cnts[0] if len(cnts) == 2 else cnts[1]
      for (let i = 0; i < edge_contours.size(); i++) {
        const rect = cv.boundingRect(edge_contours.get(i));
        cv.rectangle(src,
          new cv.Point(rect.x, rect.y),
          new cv.Point(rect.x + rect.width, rect.y + rect.height),
          [0, 255, 0, 255],
          1)
      }

      cv.imshow('canvasOutput', src);

      //
      src.delete();
      dst.delete();
      hierarchy.delete();
      contours.delete();
    }
    imgElement.onload = function () {
      myCode();
    };
    function onOpenCvReady() {
      document.getElementById('status').innerHTML =
        'Rainbow Stave is ready. Please click on the "Choose file" button to select your sheet music file on your computer.';
    }
  </script>
  <script async src="https://docs.opencv.org/3.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</body>

</html>