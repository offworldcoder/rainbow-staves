<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        margin: 0;
        font-family: Arial, Helvetica, sans-serif;
      }
    </style>
    <meta charset="utf-8" />
    <title>Rainbow Staves</title>
  </head>

  <body>
    <h1>Rainbow Staves</h1>
    <p id="status"></p>
    <div>
      <div class="loading" id="loading">
        <h1>Loading...</h1>
      </div>
      <div class="inputoutput" id="inputoutput" style="display: none">
        <img id="wholenote" src="./wholenote.png" style="display: none" />
        <canvas id="canvasOutput"></canvas>
        <img id="imageSrc" alt="" />
        <div class="caption">
          Sheet Music file to Colourize ->
          <input type="file" id="fileInput" name="file" />
        </div>
      </div>
    </div>
    <script type="text/javascript">
      //TODO:
      // DRAW OVER NOTES to place them on top of the staves unless there's a better approach
      // SAVE OPTIONS
      // use PDF's

      const DEBUG_DISPLAY = true;
      let imgElement = document.getElementById("imageSrc");
      let inputElement = document.getElementById("fileInput");
      inputElement.addEventListener(
        "change",
        (e) => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
        },
        false
      );

      function sortContours(contours) {
        let sortableContours = [];
        for (let i = 0; i < contours.size(); i++) {
          const rect = cv.boundingRect(contours.get(i));
          sortableContours.push({
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
          });
        }

        //Sort 'em
        sortableContours = sortableContours.sort((item1, item2) => {
          return item1.y < item2.y ? -1 : item1.y > item2.y ? 1 : 0;
        });

        return sortableContours;
      }

      imgElement.onload = function () {
        let wholeNote = cv.imread("wholenote", 0);
        let src = cv.imread(imgElement);

        // Preprocess Convert everything to grayscale
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_BGR2GRAY, 0);

        wholeNote2 = new cv.Mat();
        cv.cvtColor(wholeNote, wholeNote2, cv.COLOR_BGR2GRAY, 0);

        thresh = new cv.Mat();
        cv.threshold(
          gray,
          thresh,
          0,
          255,
          cv.THRESH_BINARY_INV + cv.THRESH_OTSU
        )[1];

        const { maxLength, sortedContours } = findTheStaves(thresh);
        const notePositions = findTheNotes(gray, src);
        const newContours = cutoutNotesFromStaves(
          sortedContours,
          notePositions,
          src
        );
        drawStaves(newContours, src, maxLength);
        cv.imshow("canvasOutput", src);

        // Clean up
        wholeNote2.delete();
        wholeNote.delete();
        src.delete();
        gray.delete();
        thresh.delete();
      };
      function onOpenCvReady() {
        document.getElementById("loading").style.display = "none";
        document.getElementById("inputoutput").style.display = "block";
        document.getElementById("status").innerHTML =
          'Rainbow Stave is ready. Please click on the "Choose file" button to select your sheet music file on your computer.';
      }
      function findTheStaves(thresh) {
        // Find Staves
        let horizontal_kernel = cv.Mat.ones(1, 40, cv.CV_8U);
        let anchor = new cv.Point(-1, -1);

        detect_horizontal = new cv.Mat();
        cv.morphologyEx(
          thresh,
          detect_horizontal,
          cv.MORPH_OPEN,
          horizontal_kernel,
          anchor,
          2
        );

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        cv.findContours(
          detect_horizontal,
          contours,
          hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        const sortedContours = sortContours(contours);

        // work out how long the staves are (mostly)
        let maxLength = 0;
        let minLength = 9999;
        let total = 0;
        let counter = 0;
        for (i in sortedContours) {
          counter += 1;
          const rect = sortedContours[i];
          maxLength = Math.max(maxLength, rect.width);
          minLength = Math.min(minLength, rect.width);
          total = total + rect.width;
        }

        hierarchy.delete();
        contours.delete();

        console.log(`sortedContours.length ${counter}`);
        const averageWidth = total / counter;
        console.log(
          `length min ${minLength} max ${maxLength} average ${averageWidth}`
        );
        return { maxLength, sortedContours };
      }

      function findTheNotes(gray, src) {
        let mask = new cv.Mat();
        let threshold = 0.5;
        max_val = 1;
        counter = 0;
        let notePositions = [];

        let matched = new cv.Mat();
        cv.matchTemplate(gray, wholeNote2, matched, cv.TM_CCOEFF_NORMED);

        let maxVal = null;
        let minVal = null;
        while (counter < 1000) {
          counter = counter + 1;

          const minMax = cv.minMaxLoc(matched);
          const x = minMax.maxLoc.x;
          const y = minMax.maxLoc.y;

          if (maxVal === null) {
            maxVal = minMax.maxVal;
          }
          const value = minMax.maxVal;
          if (value < maxVal * 0.9) {
            break;
          }

          notePositions.push({
            x: x,
            y: y,
            width: wholeNote2.cols,
            height: wholeNote2.rows,
          });

          const topLeft = new cv.Point(x, y);
          const bottomRight = new cv.Point(
            x + wholeNote2.cols,
            y + wholeNote2.rows
          );

          let rect = new cv.Rect(x, y, x + 50, y + 50);
          cv.rectangle(
            matched,
            topLeft,
            bottomRight,
            new cv.Scalar(0, 0, 0, 255),
            cv.FILLED,
            cv.LINE_8,
            0
          );
          if (DEBUG_DISPLAY) {
            cv.rectangle(
              src,
              topLeft,
              bottomRight,
              new cv.Scalar(255, 0, 0, 255),
              2,
              cv.LINE_8,
              0
            );
          }
        }

        //Sort 'em
        sortedNotePositions = notePositions.sort((item1, item2) => {
          return item1.y == item2.y ? item1.x - item2.x : item1.y - item2.y;
        });

        let noteNumber = 1;
        for (pos in sortedNotePositions) {
          cv.putText(
            src,
            String(noteNumber),
            new cv.Point(pos.x, pos.y),
            cv.FONT_ITALIC,
            10,
            new cv.Scalar(255, 0, 0, 255),
            2
          );
          noteNumber += 1;
        }

        return sortedNotePositions;
      }
      function cutoutNotesFromStaves(sortedContours, notePositions, src) {
        const EXTRA_HEIGHT = 2;
        const copyOfSortedContours = [...sortedContours];
        let outputContours = [];
        console.log(`copyOfSortedContours ${copyOfSortedContours.length}`);

        let counter = 0;
        for (i in copyOfSortedContours) {
          const staveRect = copyOfSortedContours[i];
          console.log(
            `NFS [${counter}] staveRect ${JSON.stringify(staveRect)}`
          );

          counter = counter + 1;
          if (counter > 5) {
            console.log(`reached counter limit so exiting`);
            break;
          }

          let staveLeft = staveRect.x;
          let wasNotOverlap = false;
          let verticalShift = 0;
          for (pos in notePositions) {
            const noteRect = notePositions[pos];
            console.log(
              `NFS  staveLeft ${staveLeft} noteRect ${JSON.stringify(noteRect)}`
            );

            if (noteRect.y > staveRect.y) {
              console.log(
                `NFS   note is below this stave, moving to next stave`
              );
              break;
            }

            // Overlap?
            if (
              noteRect.y - noteRect.height / 2 < staveRect.y &&
              noteRect.y + noteRect.height > staveRect.y
            ) {
              wasNotOverlap = true;
              console.log(`NFS   *** overlap, splitting stave into two`);
              const leftStave = {
                x: staveLeft,
                y: staveRect.y + verticalShift,
                width: noteRect.x - staveLeft,
                height: staveRect.height + EXTRA_HEIGHT,
                real: true,
              };
              staveLeft = noteRect.x + noteRect.width;
              console.log(
                `NFS   adding left stave section ${JSON.stringify(leftStave)}`
              );
              outputContours.push(leftStave);
              verticalShift += 2;
            }
          }

          if (wasNotOverlap) {
            const rightStave = {
              x: staveLeft,
              y: staveRect.y,
              width: staveRect.x + staveRect.width - staveLeft,
              height: staveRect.height + EXTRA_HEIGHT + (DEBUG_DISPLAY ? 4 : 0),
              real: true,
            };

            console.log(`NFS   adding right ${JSON.stringify(rightStave)}`);
            outputContours.push(rightStave);
          } else {
            console.log(`NFS  keeping original stave`);
            outputContours.push(staveRect);
          }
        }
        return outputContours;
      }

      function drawStaves(sortedContours, src, maxLength) {
        // draw contours
        const colours = [
          [245, 80, 87, 255],
          [237, 177, 231, 255],
          [67, 74, 220, 255],
          [165, 216, 180, 255],
          [223, 230, 100, 255],
          [252, 172, 60, 255],
          [245, 80, 87, 255],
          [213, 95, 204, 255],
          [67, 74, 220, 255],
          [165, 216, 180, 255],
        ];

        let colour_idx = 0;
        let colour = colours[colour_idx];

        let previousStaveY = 0;
        for (i in sortedContours) {
          const rect = sortedContours[i];
          console.log(`=> stave x ${rect.x} y ${rect.y} real ${rect.real}`);

          // Only draw real (manually added) horizontal lines or those which are long enough to be considered part of the stave
          if (rect.real || rect.width > maxLength / 2) {
            if (rect.y != previousStaveY) {
              console.log(
                `changing colour as stave y has changed from ${previousStaveY} to x ${rect.x} y ${rect.y} real ${rect.real}`
              );

              previousStaveY = rect.y;
              colour_idx = colour_idx + 1;
              if (colour_idx == colours.length) {
                colour_idx = 0;
              }
              colour = colours[colour_idx];
            } else {
              console.log(`keeping colour`);
            }

            if (rect.real) {
              cv.rectangle(
                src,
                new cv.Point(rect.x, rect.y),
                new cv.Point(rect.x + rect.width, rect.y + rect.height),
                new cv.Scalar(100, 0, 255, 255), //colour,
                -1
              );
              if (DEBUG_DISPLAY) {
                cv.rectangle(
                  src,
                  new cv.Point(rect.x, rect.y - 10),
                  new cv.Point(rect.x, rect.y + rect.height + 20),
                  new cv.Scalar(0, 255, 0, 255), //colour,
                  -1
                );
                cv.rectangle(
                  src,
                  new cv.Point(rect.x + rect.width, rect.y - 10),
                  new cv.Point(rect.x + rect.width, rect.y + rect.height + 20),
                  new cv.Scalar(0, 0, 0, 255), //colour,
                  -1
                );
              }
            } else {
              // cv.rectangle(
              //   src,
              //   new cv.Point(rect.x, rect.y),
              //   new cv.Point(rect.x + rect.width, rect.y + rect.height),
              //   colour,
              //   1
              // );
            }
          }
        }
      }
    </script>
    <script
      async
      src="https://docs.opencv.org/3.4/opencv.js"
      onload="onOpenCvReady();"
      type="text/javascript"
    ></script>
  </body>
</html>
