<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Rainbow Staves</title>
</head>

<body>
  <h2>Rainbow Staves</h2>
  <p id="status">Rainbow Stave is loading...</p>
  <div>
    <div class="inputoutput">
      <img id="wholenote" src='./wholenote.png' />
      <canvas id="canvasOutput"></canvas>
      <img id="imageSrc" alt="" />
      <div class="caption">
        Sheet Music file to Colourize ->
        <input type="file" id="fileInput" name="file" />
      </div>
    </div>
  </div>
  <script type="text/javascript">
    //TODO:
    // * SORT (cnts, boundingBoxes) = sort_contours(cnts, method="top-to-bottom")
    // REMOVE HORIZONTAL LINES THAT ARE TOO SHORT (ONLY USE THE LONG ONES)
    // DRAW OVER NOTES to place them on top of the staves unless there's a better approach
    // SAVE OPTIONS
    // use PDF's

    let imgElement = document.getElementById('imageSrc');
    let inputElement = document.getElementById('fileInput');
    inputElement.addEventListener(
      'change',
      (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);
      },
      false
    );

    function sortContours(contours) {
      let sortableContours = [];
      for (let i = 0; i < contours.size(); i++) {
        const rect = cv.boundingRect(contours.get(i));
        sortableContours.push({ x: rect.x, y: rect.y, width: rect.width, height: rect.height });
      }

      //Sort 'em
      sortableContours = sortableContours.sort((item1, item2) => {
        return (item1.y < item2.y) ? -1 : (item1.y > item2.y) ? 1 : 0;
      });

      // for (idx in sortableContours) {
      //   const contour = sortableContours[idx]
      //   console.log(`sorted contour ${JSON.stringify(contour)}`)
      // }

      return sortableContours
    }

    function myCode() {
      let wholeNote = cv.imread('wholenote', 0)

      let src = cv.imread(imgElement);
      let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC4);
      src.copyTo(dst);

      // Preprocess
      gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_BGR2GRAY, 0);

      wholeNote2 = new cv.Mat();
      cv.cvtColor(wholeNote, wholeNote2, cv.COLOR_BGR2GRAY, 0);

      thresh = new cv.Mat();
      cv.threshold(
        gray,
        thresh,
        0,
        255,
        cv.THRESH_BINARY_INV + cv.THRESH_OTSU
      )[1];

      // Find Staves
      let horizontal_kernel = cv.Mat.ones(1, 40, cv.CV_8U);
      let anchor = new cv.Point(-1, -1);

      detect_horizontal = new cv.Mat();
      cv.morphologyEx(
        thresh,
        detect_horizontal,
        cv.MORPH_OPEN,
        horizontal_kernel,
        anchor,
        2
      );

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();

      cv.findContours(
        detect_horizontal,
        contours,
        hierarchy,
        cv.RETR_EXTERNAL,
        cv.CHAIN_APPROX_SIMPLE
      );

      const colours = [
        [245, 80, 87, 255],
        [237, 177, 231, 255],
        [67, 74, 220, 255],
        [165, 216, 180, 255],
        [223, 230, 100, 255],
        [252, 172, 60, 255],
        [245, 80, 87, 255],
        [213, 95, 204, 255],
        [67, 74, 220, 255],
        [165, 216, 180, 255],
      ];

      const sortedContours = sortContours(contours)

      // work out how long the staves are (mostly)
      let maxLength = 0
      let minLength = 9999
      let total = 0
      let counter = 0
      for (i in sortedContours) {
        counter += 1
        const rect = sortedContours[i];
        maxLength = Math.max(maxLength, rect.width);
        minLength = Math.min(minLength, rect.width)
        total = total + rect.width;
      }

      console.log(`sortedContours.length ${counter}`)
      const averageWidth = total / counter;
      console.log(`length min ${minLength} max ${maxLength} average ${averageWidth}`)



      //TODO: draw over the notes to place them on top of the staves unless there's a better approach
      // edge_kernel = np.array([[ 0.0, -1, 0],
      //                         [ -1, 4, -1],
      //                         [ 0, -1, 0]], dtype=np.uint8)

      // Find the notes
      let mask = new cv.Mat()
      let threshold = 0.50
      max_val = 1
      counter = 0
      let notePositions = []

      let matched = new cv.Mat();
      cv.matchTemplate(
        gray,
        wholeNote2,
        matched,
        cv.TM_CCOEFF_NORMED,
      )


      let maxVal = null
      let minVal = null
      while (counter < 1) { //1000) {
        counter = counter + 1

        const minMax = cv.minMaxLoc(matched);
        const x = minMax.maxLoc.x;
        const y = minMax.maxLoc.y;

        if (maxVal === null) {
          maxVal = minMax.maxVal;
        }
        const value = minMax.maxVal;
        if (value < maxVal * 0.9) {
          break;
        }

        notePositions.push({ x: x, y: y, width: wholeNote2.cols, height: wholeNote2.rows });

        const topLeft = new cv.Point(x, y)
        const bottomRight = new cv.Point(x + wholeNote2.cols, y + wholeNote2.rows)

        let rect = new cv.Rect(x, y, x + 50, y + 50);
        cv.rectangle(matched, topLeft, bottomRight, new cv.Scalar(0, 0, 0, 255), cv.FILLED, cv.LINE_8, 0)
        cv.rectangle(src, topLeft, bottomRight, new cv.Scalar(255, 0, 0, 255), 3, cv.LINE_8, 0)
      }

      const originalSortedContours = sortedContours
      console.log(`originalSortedContours ${originalSortedContours.length}`)

      for (pos in notePositions) {
        const noteRect = notePositions[pos]
        console.log(`noteRect ${JSON.stringify(noteRect)}`)

        for (i in originalSortedContours) {
          const staveRect = originalSortedContours[i];
          console.log(`staveRect ${JSON.stringify(staveRect)}`)

          // Overlap left end
          if (noteRect.y < staveRect.y && noteRect.y + noteRect.height > staveRect.y) {
            console.log(`*** on stave line`)
            if (noteRect.x < staveRect.x && noteRect.x + noteRect.width > staveRect.x) {
              staveRect.x = staveRect.x + 10
              staveRect.y = staveRect.y + 5
              staveRect.width = staveRect.width - 20

              const leftStave = {
                x: staveRect.x + 10,
                y: staveRect.y + 5,
                width: staveRect.width - 20,
                height: staveRect.height
              };

              console.log(`moving stave right ${JSON.stringify(leftStave)}`)
              sortedContours.push(leftStave);
            }
            else {
              if (noteRect.x < staveRect.x + staveRect.width && noteRect.x + noteRect.width > staveRect.x + staveRect.width) {
                staveRect.y = staveRect.y + 5
                staveRect.width = staveRect.width - 10

                const leftStave = {
                  x: staveRect.x,
                  y: staveRect.y + 5,
                  width: staveRect.width - 10,
                  height: staveRect.height
                };

                console.log(`reducing stave length ${JSON.stringify(leftStave)}`)
                sortedContours.push(leftStave);
              }
            }
          }

          // Overlap?
          if (noteRect.y - (noteRect.height / 2) < staveRect.y && noteRect.y + noteRect.height > staveRect.y) {
            console.log(`*** overlap, splitting stave into two`)
            const leftStave = {
              x: staveRect.x,
              y: staveRect.y,
              width: noteRect.x - staveRect.x - (noteRect.width / 2),
              height: staveRect.height + 5,
              real: true
            };
            const rightStave = {
              x: noteRect.x + (noteRect.width / 2),
              y: staveRect.y,
              width: (staveRect.x + staveRect.width - noteRect.x),
              height: staveRect.height + 5,
              real: true
            };

            //TODO: are the staves already around the notes?
            console.log(`adding left ${JSON.stringify(leftStave)}`)
            sortedContours.push(leftStave);
            console.log(`adding right ${JSON.stringify(rightStave)}`)
            sortedContours.push(rightStave);
          }
        }
      }
      //TODO: Make gaps in the horizontal staves where the rectangles are

      // cv.imshow('canvasOutput', src);

      console.info('3')

      // draw contours
      let colour_idx = 0;
      for (i in sortedContours) {
        const rect = sortedContours[i];

        // Only draw horizontal lines  which are long enough to be considered part of the stave
        if (rect.real || rect.width > maxLength / 2) {
          let colour = colours[colour_idx];
          colour_idx = colour_idx + 1;
          if (colour_idx == colours.length) {
            colour_idx = 0;
          }
          cv.rectangle(src,
            new cv.Point(rect.x, rect.y),
            new cv.Point(rect.x + rect.width, rect.y + rect.height),
            colour,
            1)
        }
      }

      cv.imshow('canvasOutput', src);

      //
      src.delete();
      dst.delete();
      hierarchy.delete();
      contours.delete();
    }
    imgElement.onload = function () {
      myCode();
    };
    function onOpenCvReady() {
      document.getElementById('status').innerHTML =
        'Rainbow Stave is ready. Please click on the "Choose file" button to select your sheet music file on your computer.';
    }
  </script>
  <script async src="https://docs.opencv.org/3.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</body>

</html>