<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Hello OpenCV.js</title>
  </head>
  <body>
    <h2>Hello OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <div>
      <div class="inputoutput">
        <img id="imageSrc" alt="No Image" />
        <div class="caption">
          imageSrc <input type="file" id="fileInput" name="file" />
        </div>
      </div>
      <div class="inputoutput">
        <canvas id="canvasOutput"></canvas>
        <div class="caption">canvasOutput</div>
        <canvas id="canvasOutput2"></canvas>
        <div class="caption">canvasOutput2</div>
      </div>
    </div>
    <script type="text/javascript">
      let imgElement = document.getElementById('imageSrc');
      let inputElement = document.getElementById('fileInput');
      inputElement.addEventListener(
        'change',
        (e) => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
        },
        false
      );

      function exampleCode() {
        let src = cv.imread(imgElement);
        let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
        cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(src, src, 100, 200, cv.THRESH_BINARY);
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        let poly = new cv.MatVector();
        cv.findContours(
          src,
          contours,
          hierarchy,
          cv.RETR_CCOMP,
          cv.CHAIN_APPROX_SIMPLE
        );
        // approximates each contour to polygon
        for (let i = 0; i < contours.size(); ++i) {
          let tmp = new cv.Mat();
          let cnt = contours.get(i);
          // You can try more different parameters
          cv.approxPolyDP(cnt, tmp, 3, true);
          poly.push_back(tmp);
          cnt.delete();
          tmp.delete();
        }
        // draw contours with random Scalar
        for (let i = 0; i < contours.size(); ++i) {
          let color = new cv.Scalar(
            Math.round(Math.random() * 255),
            Math.round(Math.random() * 255),
            Math.round(Math.random() * 255)
          );
          cv.drawContours(dst, poly, i, color, 1, 8, hierarchy, 0);
        }
        cv.imshow('canvasExampleOutput', dst);
        src.delete();
        dst.delete();
        hierarchy.delete();
        contours.delete();
        poly.delete();
      }

      function myCode() {
        let src = cv.imread(imgElement);
        let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
        gray = cv.cvtColor(src, src, cv.COLOR_BGR2GRAY, 0);
        thresh = cv.threshold(
          src,
          src,
          0,
          255,
          cv.THRESH_BINARY_INV + cv.THRESH_OTSU
        )[1];

        cv.imshow('canvasOutput', src);

        let horizontal_kernel = cv.Mat.ones(1, 40, cv.CV_8U);
        let anchor = new cv.Point(-1, -1);

        detect_horizontal = cv.morphologyEx(
          src,
          src,
          cv.MORPH_OPEN,
          horizontal_kernel,
          anchor,
          2
        );

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        let poly = new cv.MatVector();

        cv.findContours(
          src,
          contours,
          hierarchy,
          cv.RETR_EXTERNAL,
          cv.CHAIN_APPROX_SIMPLE
        );

        // cnts = cnts[0] if len(cnts) == 2 else cnts[1]
        // SORT (cnts, boundingBoxes) = sort_contours(cnts, method="top-to-bottom")
        // REMOVE HORIZONTAL LINES THAT ARE TOO SHORT (ONLY USE THE LONG ONES)
        const colours = [
          new cv.Scalar(87, 80, 245), // red (line 1)
          new cv.Scalar(231, 177, 237),
          new cv.Scalar(220, 74, 67),
          new cv.Scalar(180, 216, 165),
          new cv.Scalar(100, 230, 223),
          new cv.Scalar(60, 172, 252),
          new cv.Scalar(87, 80, 245),
          new cv.Scalar(204, 95, 213),
          new cv.Scalar(220, 74, 67),
          new cv.Scalar(180, 216, 165),
        ];

        for (let i = 0; i < contours.size(); ++i) {
          let tmp = new cv.Mat();
          let cnt = contours.get(i);
          // You can try more different parameters
          cv.approxPolyDP(cnt, tmp, 3, true);
          poly.push_back(tmp);
          cnt.delete();
          tmp.delete();
        }
        // draw contours with random Scalar
        let colour_idx = 0;
        for (let i = 0; i < contours.size(); ++i) {
          let colour = colours[colour_idx];
          colour_idx = colour_idx + 1;
          if (colour_idx == colours.length) colour_idx = 0;
          cv.drawContours(dst, poly, i, colour, 1, 8, hierarchy, 0);
        }

        cv.imshow('canvasOutput2', dst);

        // for c in cnts:
        //     cv2.drawContours(result, [c], -1, colors[color_idx], 2)
        //     color_idx += 1
        //     if color_idx == len(colors):
        //         color_idx = 0

        // edge_kernel = np.array([[ 0.0, -1, 0],
        //                         [ -1, 4, -1],
        //                         [ 0, -1, 0]], dtype=np.uint8)
        // detect_edge = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, edge_kernel, iterations=2)
        // cnts = cv2.findContours(detect_edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        // cnts = cnts[0] if len(cnts) == 2 else cnts[1]
        // for c in cnts:
        //     cv2.fillPoly(result, [c], (0,0,0))

        //
        // mat.delete();
      }
      imgElement.onload = function () {
        myCode();
        // exampleCode();
      };
      function onOpenCvReady() {
        document.getElementById('status').innerHTML = 'OpenCV.js is ready.';
      }
    </script>
    <script
      async
      src="opencv.js"
      onload="onOpenCvReady();"
      type="text/javascript"
    ></script>
  </body>
</html>
