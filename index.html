<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Rainbow Staves</title>
</head>

<body>
  <h2>Rainbow Staves</h2>
  <p id="status">Rainbow Stave is loading...</p>
  <div>
    <div class="inputoutput">
      <canvas id="canvasOutput"></canvas>
      <img id="imageSrc" alt="" />
      <div class="caption">
        Sheet Music file to Colourize ->
        <input type="file" id="fileInput" name="file" />
      </div>
    </div>
  </div>
  <script type="text/javascript">
    //TODO:
    // SORT (cnts, boundingBoxes) = sort_contours(cnts, method="top-to-bottom")
    // REMOVE HORIZONTAL LINES THAT ARE TOO SHORT (ONLY USE THE LONG ONES)
    // SAVE OPTIONS
    // use PDF's

    let imgElement = document.getElementById('imageSrc');
    let inputElement = document.getElementById('fileInput');
    inputElement.addEventListener(
      'change',
      (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);
      },
      false
    );

    function sortStaves(contours) {
      let sortableContours = [];
      for (let i = 0; i < contours.size(); i++) {
        const rect = cv.boundingRect(contours.get(i));
        console.log(`rect ${rect.y} contour ${JSON.stringify(contours.get(i)[0])}`)
        sortableContours.push({ x: rect.x, y: rect.y, width: rect.width, height: rect.height });
      }

      //TODO: Would be nicer to be able to sort the original contours array but it doesn't have a sort method
      // contours.sort((item1, item2) => {
      //   const rect1 = item1.boundingRect();
      //   const rect2 = item2.boundingRect();
      //   return (rect1.y < rect2.y) ? -1 : (rect1.y > rect2.y) ? 1 : 0;
      // })

      // for (idx in contours) {
      //   const contour = contours[idx]
      //   console.log(`sorted contour ${JSON.stringify(contour)}`)
      // }

      //Sort 'em
      sortableContours = sortableContours.sort((item1, item2) => {
        return (item1.y < item2.y) ? -1 : (item1.y > item2.y) ? 1 : 0;
      });

      for (idx in sortableContours) {
        const contour = sortableContours[idx]
        console.log(`sorted contour ${JSON.stringify(contour)}`)
      }

      return contours
    }

    function myCode() {
      let src = cv.imread(imgElement);
      let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC4);
      src.copyTo(dst);

      gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_BGR2GRAY, 0);

      thresh = new cv.Mat();
      cv.threshold(
        gray,
        thresh,
        0,
        255,
        cv.THRESH_BINARY_INV + cv.THRESH_OTSU
      )[1];

      let horizontal_kernel = cv.Mat.ones(1, 40, cv.CV_8U);
      let anchor = new cv.Point(-1, -1);

      detect_horizontal = new cv.Mat();
      cv.morphologyEx(
        thresh,
        detect_horizontal,
        cv.MORPH_OPEN,
        horizontal_kernel,
        anchor,
        2
      );

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();

      cv.findContours(
        detect_horizontal,
        contours,
        hierarchy,
        cv.RETR_EXTERNAL,
        cv.CHAIN_APPROX_SIMPLE
      );

      const colours = [
        [87, 80, 245, 255],
        [231, 177, 237, 255],
        [220, 74, 67, 255],
        [180, 216, 165, 255],
        [100, 230, 223, 255],
        [60, 172, 252, 255],
        [87, 80, 245, 255],
        [204, 95, 213, 255],
        [220, 74, 67, 255],
        [180, 216, 165, 255],
      ];

      const sortedContours = sortStaves(contours)

      // draw contours
      let colour_idx = 0;
      for (let i = 0; i < sortedContours.size(); ++i) {
        let colour = colours[colour_idx];
        colour_idx = colour_idx + 1;
        if (colour_idx == colours.length) {
          colour_idx = 0;
        }
        cv.drawContours(
          src,
          sortedContours,
          i,
          colour,
          1,
          cv.LINE_8,
          hierarchy,
          100
        );
      }

      cv.imshow('canvasOutput', src);

      // edge_kernel = np.array([[ 0.0, -1, 0],
      //                         [ -1, 4, -1],
      //                         [ 0, -1, 0]], dtype=np.uint8)
      // detect_edge = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, edge_kernel, iterations=2)
      // cnts = cv2.findContours(detect_edge, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
      // cnts = cnts[0] if len(cnts) == 2 else cnts[1]
      // for c in cnts:
      //     cv2.fillPoly(result, [c], (0,0,0))

      //
      src.delete();
      dst.delete();
      hierarchy.delete();
      contours.delete();
    }
    imgElement.onload = function () {
      myCode();
    };
    function onOpenCvReady() {
      document.getElementById('status').innerHTML =
        'Rainbow Stave is ready. Please click on the "Choose file" button to select your sheet music file on your computer.';
    }
  </script>
  <script async src="https://docs.opencv.org/3.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</body>

</html>